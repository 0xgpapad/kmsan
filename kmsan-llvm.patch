Index: include/llvm/Transforms/Instrumentation.h
===================================================================
--- include/llvm/Transforms/Instrumentation.h	(revision 315447)
+++ include/llvm/Transforms/Instrumentation.h	(working copy)
@@ -141,7 +141,8 @@
 
 // Insert MemorySanitizer instrumentation (detection of uninitialized reads)
 FunctionPass *createMemorySanitizerPass(int TrackOrigins = 0,
-                                        bool Recover = false);
+                                        bool Recover = false,
+                                        bool EnableKmsan = false);
 
 // Insert ThreadSanitizer (race detection) instrumentation
 FunctionPass *createThreadSanitizerPass();
Index: lib/Transforms/Instrumentation/MemorySanitizer.cpp
===================================================================
--- lib/Transforms/Instrumentation/MemorySanitizer.cpp	(revision 315447)
+++ lib/Transforms/Instrumentation/MemorySanitizer.cpp	(working copy)
@@ -88,6 +88,23 @@
 /// implementation ignores the load aspect of CAS/RMW, always returning a clean
 /// value. It implements the store part as a simple atomic store by storing a
 /// clean shadow.
+///
+///                  KernelMemorySanitizer (KMSAN) implementation.
+///
+/// The major differences between KMSAN and MSan instrumentation are:
+///  - KMSAN implies msan-track-origins=2, msan-keep-going=true;
+///  - KMSAN allocates shadows and origins for each page separately, so there
+///    are no explicit accesses to shadow and origin memory.
+///    Shadow and origin values for a particular X-byte memory location
+///    (X=1,2,4,8) are read using __msan_load_shadow_origin_X(u8 *addr) and
+///    written using
+///    __msan_store_shadow_origin_X(u8 *addr, uptr shadow, uptr origin);
+///  - TLS variables are stored in a single struct in per-task storage. A call
+///    to a function __msan_get_context_state() returning a pointer to that
+///    struct is inserted into every instrumented function before the entry block;
+///  - __msan_warning() now becomes __msan_warning_32(uptr origin)
+///
+///  KernelMemorySanitizer only supports X86_64 at the moment.
 
 //===----------------------------------------------------------------------===//
 
@@ -161,6 +178,17 @@
        cl::desc("exact handling of relational integer ICmp"),
        cl::Hidden, cl::init(false));
 
+static cl::opt<bool>
+    ClEnableKmsan("msan-kernel",
+                  cl::desc("Enable KernelMemorySanitizer instrumentation"),
+                  cl::Hidden, cl::init(false));
+
+static cl::opt<bool>
+    ClKmsanUseMetaPointers("msan-kernel-use-meta-pointers",
+                  cl::desc("use-meta-pointers"),
+                  cl::Hidden, cl::init(true));
+
+
 // This flag controls whether we check the shadow of the address
 // operand of load or store. Such bugs are very rare, since load from
 // a garbage address typically results in SEGV, but still happen
@@ -312,14 +340,15 @@
 /// uninitialized reads.
 class MemorySanitizer : public FunctionPass {
  public:
-  MemorySanitizer(int TrackOrigins = 0, bool Recover = false)
-      : FunctionPass(ID),
-        TrackOrigins(std::max(TrackOrigins, (int)ClTrackOrigins)),
-        Recover(Recover || ClKeepGoing),
-        WarningFn(nullptr) {}
-  StringRef getPassName() const override { return "MemorySanitizer"; }
-  void getAnalysisUsage(AnalysisUsage &AU) const override {
-    AU.addRequired<TargetLibraryInfoWrapperPass>();
+   MemorySanitizer(int TrackOrigins = 0, bool Recover = false,
+                   bool EnableKmsan = false)
+       : FunctionPass(ID), CompileKernel(EnableKmsan || ClEnableKmsan),
+         TrackOrigins(
+             CompileKernel ? 2 : std::max(TrackOrigins, (int)ClTrackOrigins)),
+         Recover(Recover || ClKeepGoing || CompileKernel), WarningFn(nullptr) {}
+   StringRef getPassName() const override { return "MemorySanitizer"; }
+   void getAnalysisUsage(AnalysisUsage &AU) const override {
+     AU.addRequired<TargetLibraryInfoWrapperPass>();
   }
   bool runOnFunction(Function &F) override;
   bool doInitialization(Module &M) override;
@@ -327,7 +356,12 @@
 
  private:
   void initializeCallbacks(Module &M);
+  void initializeKmsanCallbacks(Module &M);
+  void createUserspaceGlobals(Module &M);
 
+  /// \brief True if we're compiling the Linux kernel.
+  bool CompileKernel;
+
   /// \brief Track origins (allocation points) of uninitialized values.
   int TrackOrigins;
   bool Recover;
@@ -336,25 +370,26 @@
   Type *IntptrTy;
   Type *OriginTy;
   /// \brief Thread-local shadow storage for function parameters.
-  GlobalVariable *ParamTLS;
+  Value *ParamTLS;
   /// \brief Thread-local origin storage for function parameters.
-  GlobalVariable *ParamOriginTLS;
+  Value *ParamOriginTLS;
   /// \brief Thread-local shadow storage for function return value.
-  GlobalVariable *RetvalTLS;
+  Value *RetvalTLS;
   /// \brief Thread-local origin storage for function return value.
-  GlobalVariable *RetvalOriginTLS;
+  Value *RetvalOriginTLS;
   /// \brief Thread-local shadow storage for in-register va_arg function
   /// parameters (x86_64-specific).
-  GlobalVariable *VAArgTLS;
+  Value *VAArgTLS;
   /// \brief Thread-local shadow storage for va_arg overflow area
   /// (x86_64-specific).
-  GlobalVariable *VAArgOverflowSizeTLS;
+  Value *VAArgOverflowSizeTLS;
   /// \brief Thread-local space used to pass origin value to the UMR reporting
   /// function.
-  GlobalVariable *OriginTLS;
+  Value *OriginTLS;
 
   /// \brief The run-time callback to print a warning.
   Value *WarningFn;
+  Value *MsanWarning32Fn;
   // These arrays are indexed by log2(AccessSize).
   Value *MaybeWarningFn[kNumberOfAccessSizes];
   Value *MaybeStoreOriginFn[kNumberOfAccessSizes];
@@ -362,6 +397,18 @@
   /// \brief Run-time helper that generates a new origin value for a stack
   /// allocation.
   Value *MsanSetAllocaOrigin4Fn;
+
+  Value *getKmsanShadowOriginAccessFn(bool isStore, int size);
+
+  Value *MsanPoisonAllocaFn;
+  Value *MsanUnpoisonFn;
+  Value *MsanLoadArgShadowFn;
+  Value *MsanStoreArgShadowFn;
+#if 0
+  Value *MsanLoadArgOriginFn;
+#endif
+  Value *MsanStoreArgOriginFn;
+  Value *MsanStoreArgShadowOriginFn;
   /// \brief Run-time helper that poisons stack on function entry.
   Value *MsanPoisonStackFn;
   /// \brief Run-time helper that records a store (or any event) of an
@@ -370,6 +417,18 @@
   /// \brief MSan runtime replacements for memmove, memcpy and memset.
   Value *MemmoveFn, *MemcpyFn, *MemsetFn;
 
+  /// \brief KMSAN callbacks for task-local function argument shadow.
+  Value *GetContextStateFn;
+  Value *LoadShadowOrigin_1_8_Fn[4];
+  Value *LoadShadowOrigin_n_8_Fn;
+  Value *StoreShadowOrigin_1_8_Fn[4];
+  Value *StoreShadowOrigin_n_8_Fn;
+
+  /// \brief function returning a pair of shadow/origin pointers.
+  Value *MsanMetadataPtrForLoadN, *MsanMetadataPtrForStoreN;
+  Value *MsanMetadataPtrForLoad_1_8[4];
+  Value *MsanMetadataPtrForStore_1_8[4];
+
   /// \brief Memory map parameters used in application-to-shadow calculation.
   const MemoryMapParams *MapParams;
 
@@ -397,8 +456,9 @@
     MemorySanitizer, "msan",
     "MemorySanitizer: detects uninitialized reads.", false, false)
 
-FunctionPass *llvm::createMemorySanitizerPass(int TrackOrigins, bool Recover) {
-  return new MemorySanitizer(TrackOrigins, Recover);
+FunctionPass *llvm::createMemorySanitizerPass(int TrackOrigins, bool Recover,
+                                              bool CompileKernel) {
+  return new MemorySanitizer(TrackOrigins, Recover, CompileKernel);
 }
 
 /// \brief Create a non-const global initialized with the given string.
@@ -413,6 +473,164 @@
                             GlobalValue::PrivateLinkage, StrConst, "");
 }
 
+/// \brief Create KMSAN API callbacks.
+void MemorySanitizer::initializeKmsanCallbacks(Module &M) {
+  IRBuilder<> IRB(*C);
+
+  // MSan globals won't be used.
+  RetvalTLS = nullptr;
+  RetvalOriginTLS = nullptr;
+  ParamTLS = nullptr;
+  ParamOriginTLS = nullptr;
+  VAArgTLS = nullptr;
+  VAArgOverflowSizeTLS = nullptr;
+  OriginTLS = nullptr;
+
+  // Like __msan_warning(), but takes an origin.
+  MsanWarning32Fn = M.getOrInsertFunction("__msan_warning_32", IRB.getVoidTy(),
+                                          IRB.getInt32Ty());
+  // Requests the per-task context state (kmsan_context_state*) from the
+  // runtime library.
+  GetContextStateFn = M.getOrInsertFunction(
+      "__msan_get_context_state",
+      PointerType::get(
+          StructType::get(ArrayType::get(IRB.getInt64Ty(), kParamTLSSize / 8),
+                          ArrayType::get(IRB.getInt64Ty(), kRetvalTLSSize / 8),
+                          ArrayType::get(IRB.getInt64Ty(), kParamTLSSize / 8),
+                          IRB.getInt64Ty(),
+                          ArrayType::get(OriginTy, kParamTLSSize / 4), OriginTy,
+                          OriginTy),
+          0));
+
+  if (!ClKmsanUseMetaPointers) {
+    // Shadow/origin getters and setters for 1,2,4,8-byte accesses. Like with
+    // MSan instrumentation, origin is always 4 bytes, even for 8-byte loads and
+    // stores.
+    for (int ind = 0, size = 1; ind < 4; ind++, size <<= 1) {
+      std::string name_load = "__msan_load_shadow_origin_" + std::to_string(size);
+      std::string name_store =
+          "__msan_store_shadow_origin_" + std::to_string(size);
+      LoadShadowOrigin_1_8_Fn[ind] = M.getOrInsertFunction(
+          name_load, StructType::get(IRB.getInt64Ty(), IRB.getInt32Ty()),
+          PointerType::get(IRB.getInt8Ty(), 0));
+      StoreShadowOrigin_1_8_Fn[ind] = M.getOrInsertFunction(
+          name_store, IRB.getVoidTy(), PointerType::get(IRB.getInt8Ty(), 0),
+          IRB.getInt64Ty(), IRB.getInt64Ty());
+      MsanMetadataPtrForLoad_1_8[ind] = nullptr;
+      MsanMetadataPtrForStore_1_8[ind] = nullptr;
+    }
+
+    // Shadow/origin getters and setters for arbitrary size accesses not greater
+    // than 8 bytes.
+    LoadShadowOrigin_n_8_Fn = M.getOrInsertFunction(
+        "__msan_load_shadow_origin_n_8",
+        StructType::get(IRB.getInt64Ty(), IRB.getInt32Ty()),
+        PointerType::get(IRB.getInt8Ty(), 0), IRB.getInt64Ty());
+    StoreShadowOrigin_n_8_Fn = M.getOrInsertFunction(
+        "__msan_store_shadow_origin_n_8", IRB.getVoidTy(),
+        PointerType::get(IRB.getInt8Ty(), 0), IRB.getInt64Ty(), IRB.getInt64Ty(),
+        IRB.getInt64Ty());
+  } else {
+    Type *RetTy = StructType::get(
+        PointerType::get(IRB.getInt8Ty(), 0),
+        PointerType::get(IRB.getInt32Ty(), 0));
+
+    for (int ind = 0, size = 1; ind < 4; ind++, size <<= 1) {
+      LoadShadowOrigin_1_8_Fn[ind] = nullptr;
+      StoreShadowOrigin_1_8_Fn[ind] = nullptr;
+
+      std::string name_load = "__msan_metadata_ptr_for_load_" + std::to_string(size);
+      std::string name_store =
+          "__msan_metadata_ptr_for_store_" + std::to_string(size);
+      MsanMetadataPtrForLoad_1_8[ind] = M.getOrInsertFunction(
+          name_load, RetTy,
+          PointerType::get(IRB.getInt8Ty(), 0));
+      MsanMetadataPtrForStore_1_8[ind] = M.getOrInsertFunction(
+          name_store, RetTy,
+          PointerType::get(IRB.getInt8Ty(), 0));
+
+    }
+    LoadShadowOrigin_n_8_Fn = nullptr;
+    StoreShadowOrigin_n_8_Fn = nullptr;
+
+    MsanMetadataPtrForLoadN = M.getOrInsertFunction(
+        "__msan_metadata_ptr_for_load_n", RetTy,
+        PointerType::get(IRB.getInt8Ty(), 0), IRB.getInt64Ty());
+    MsanMetadataPtrForStoreN = M.getOrInsertFunction(
+        "__msan_metadata_ptr_for_store_n", RetTy,
+        PointerType::get(IRB.getInt8Ty(), 0), IRB.getInt64Ty());
+
+
+  }
+
+
+  // Functions for poisoning and unpoisoning memory.
+  MsanPoisonAllocaFn = M.getOrInsertFunction(
+      "__msan_poison_alloca", IRB.getVoidTy(), IRB.getInt8PtrTy(), IntptrTy,
+      IRB.getInt8PtrTy(), IntptrTy);
+
+  MsanUnpoisonFn = M.getOrInsertFunction("__msan_unpoison", IRB.getVoidTy(),
+                                         IRB.getInt8PtrTy(), IntptrTy);
+
+  // Functions for loading the shadow for a given memory range into an app
+  // memory buffer and storing it back to the shadow memory.
+  MsanLoadArgShadowFn =
+      M.getOrInsertFunction("__msan_load_arg_shadow", IRB.getVoidTy(),
+                            IRB.getInt8PtrTy(), IRB.getInt8PtrTy(), IntptrTy);
+  MsanStoreArgShadowFn =
+      M.getOrInsertFunction("__msan_store_arg_shadow", IRB.getVoidTy(),
+                            IRB.getInt8PtrTy(), IRB.getInt8PtrTy(), IntptrTy);
+
+  // Functions for loading the origin for a given memory range into an app
+  // memory buffer and storing it back to the origin memory.
+#if 0
+  MsanLoadArgOriginFn =
+      M.getOrInsertFunction("__msan_load_arg_origin", IRB.getVoidTy(),
+                            IRB.getInt8PtrTy(), IRB.getInt8PtrTy(), IntptrTy);
+#endif
+  MsanStoreArgOriginFn =
+      M.getOrInsertFunction("__msan_store_arg_origin", IRB.getVoidTy(),
+                            IRB.getInt8PtrTy(), IRB.getInt8PtrTy(), IntptrTy);
+  MsanStoreArgShadowOriginFn =
+      M.getOrInsertFunction("__msan_store_arg_shadow_origin", IRB.getVoidTy(),
+                            IRB.getInt8PtrTy(), IRB.getInt8PtrTy(), IRB.getInt8PtrTy(), IntptrTy);
+
+}
+
+void MemorySanitizer::createUserspaceGlobals(Module &M) {
+  IRBuilder<> IRB(*C);
+  RetvalTLS = new GlobalVariable(
+      M, ArrayType::get(IRB.getInt64Ty(), kRetvalTLSSize / 8), false,
+      GlobalVariable::ExternalLinkage, nullptr, "__msan_retval_tls", nullptr,
+      GlobalVariable::InitialExecTLSModel);
+
+  RetvalOriginTLS = new GlobalVariable(
+      M, OriginTy, false, GlobalVariable::ExternalLinkage, nullptr,
+      "__msan_retval_origin_tls", nullptr, GlobalVariable::InitialExecTLSModel);
+
+  ParamTLS = new GlobalVariable(
+      M, ArrayType::get(IRB.getInt64Ty(), kParamTLSSize / 8), false,
+      GlobalVariable::ExternalLinkage, nullptr, "__msan_param_tls", nullptr,
+      GlobalVariable::InitialExecTLSModel);
+
+  ParamOriginTLS = new GlobalVariable(
+      M, ArrayType::get(OriginTy, kParamTLSSize / 4), false,
+      GlobalVariable::ExternalLinkage, nullptr, "__msan_param_origin_tls",
+      nullptr, GlobalVariable::InitialExecTLSModel);
+
+  VAArgTLS = new GlobalVariable(
+      M, ArrayType::get(IRB.getInt64Ty(), kParamTLSSize / 8), false,
+      GlobalVariable::ExternalLinkage, nullptr, "__msan_va_arg_tls", nullptr,
+      GlobalVariable::InitialExecTLSModel);
+  VAArgOverflowSizeTLS = new GlobalVariable(
+      M, IRB.getInt64Ty(), false, GlobalVariable::ExternalLinkage, nullptr,
+      "__msan_va_arg_overflow_size_tls", nullptr,
+      GlobalVariable::InitialExecTLSModel);
+  OriginTLS = new GlobalVariable(
+      M, IRB.getInt32Ty(), false, GlobalVariable::ExternalLinkage, nullptr,
+      "__msan_origin_tls", nullptr, GlobalVariable::InitialExecTLSModel);
+}
+
 /// \brief Insert extern declaration of runtime-provided functions and globals.
 void MemorySanitizer::initializeCallbacks(Module &M) {
   // Only do this once.
@@ -459,36 +677,12 @@
     "__msan_memset", IRB.getInt8PtrTy(), IRB.getInt8PtrTy(), IRB.getInt32Ty(),
     IntptrTy);
 
-  // Create globals.
-  RetvalTLS = new GlobalVariable(
-    M, ArrayType::get(IRB.getInt64Ty(), kRetvalTLSSize / 8), false,
-    GlobalVariable::ExternalLinkage, nullptr, "__msan_retval_tls", nullptr,
-    GlobalVariable::InitialExecTLSModel);
-  RetvalOriginTLS = new GlobalVariable(
-    M, OriginTy, false, GlobalVariable::ExternalLinkage, nullptr,
-    "__msan_retval_origin_tls", nullptr, GlobalVariable::InitialExecTLSModel);
+  if (!CompileKernel) {
+    createUserspaceGlobals(M);
+  } else {
+    initializeKmsanCallbacks(M);
+  }
 
-  ParamTLS = new GlobalVariable(
-    M, ArrayType::get(IRB.getInt64Ty(), kParamTLSSize / 8), false,
-    GlobalVariable::ExternalLinkage, nullptr, "__msan_param_tls", nullptr,
-    GlobalVariable::InitialExecTLSModel);
-  ParamOriginTLS = new GlobalVariable(
-    M, ArrayType::get(OriginTy, kParamTLSSize / 4), false,
-    GlobalVariable::ExternalLinkage, nullptr, "__msan_param_origin_tls",
-    nullptr, GlobalVariable::InitialExecTLSModel);
-
-  VAArgTLS = new GlobalVariable(
-    M, ArrayType::get(IRB.getInt64Ty(), kParamTLSSize / 8), false,
-    GlobalVariable::ExternalLinkage, nullptr, "__msan_va_arg_tls", nullptr,
-    GlobalVariable::InitialExecTLSModel);
-  VAArgOverflowSizeTLS = new GlobalVariable(
-    M, IRB.getInt64Ty(), false, GlobalVariable::ExternalLinkage, nullptr,
-    "__msan_va_arg_overflow_size_tls", nullptr,
-    GlobalVariable::InitialExecTLSModel);
-  OriginTLS = new GlobalVariable(
-    M, IRB.getInt32Ty(), false, GlobalVariable::ExternalLinkage, nullptr,
-    "__msan_origin_tls", nullptr, GlobalVariable::InitialExecTLSModel);
-
   // We insert an empty inline asm after __msan_report* to avoid callback merge.
   EmptyAsm = InlineAsm::get(FunctionType::get(IRB.getVoidTy(), false),
                             StringRef(""), StringRef(""),
@@ -495,6 +689,27 @@
                             /*hasSideEffects=*/true);
 }
 
+Value *MemorySanitizer::getKmsanShadowOriginAccessFn(bool isStore, int size) {
+  Value **Fns;
+  if (ClKmsanUseMetaPointers) {
+    Fns = isStore ? MsanMetadataPtrForStore_1_8 : MsanMetadataPtrForLoad_1_8;
+  } else {
+    Fns = isStore ? StoreShadowOrigin_1_8_Fn : LoadShadowOrigin_1_8_Fn;
+  }
+  switch (size) {
+  case 1:
+    return Fns[0];
+  case 2:
+    return Fns[1];
+  case 4:
+    return Fns[2];
+  case 8:
+    return Fns[3];
+  default:
+    return nullptr;
+  }
+}
+
 /// \brief Module-level initialization.
 ///
 /// inserts a call to __msan_init to the module's constructor list.
@@ -628,6 +843,7 @@
   ValueMap<Value*, Value*> ShadowMap, OriginMap;
   std::unique_ptr<VarArgHelper> VAHelper;
   const TargetLibraryInfo *TLI;
+  BasicBlock *ActualFnStart;
 
   // The following flags disable parts of MSan instrumentation based on
   // blacklist contents and command-line options.
@@ -637,6 +853,8 @@
   bool PoisonUndef;
   bool CheckReturnValue;
 
+  SmallPtrSet<Value *, 16> SkippedFunctions;
+
   struct ShadowOriginAndInsertPoint {
     Value *Shadow;
     Value *Origin;
@@ -753,6 +971,105 @@
     }
   }
 
+  bool setShadowOriginForStoreKmsanPtrs(Instruction *I, Value *Addr,
+                                        Value *Shadow, Value *Origin) {
+    IRBuilder<> IRB(I);
+    Type *ShadowTy = Shadow->getType();
+    int BitWidth = VectorOrPrimitiveTypeSizeInBits(ShadowTy);
+    int Size = BitWidth / 8;
+    ///unsigned OriginAlignment = std::max(kMinOriginAlignment, Alignment);
+    unsigned OriginAlignment = 4; // TODO(glider)
+    // Make sure Size is at least 1 if the operand is i1.
+    if (Size * 8 < BitWidth)
+      Size++;
+
+    Value *SizeVal = ConstantInt::get(IRB.getInt64Ty(), Size);
+    Addr = IRB.CreatePointerCast(Addr, PointerType::get(IRB.getInt8Ty(), 0));
+    Value *ShadowOriginPtrs;
+    Value *Getter = MS.getKmsanShadowOriginAccessFn(/*isStore*/ true, Size);
+    if (Getter) {
+      ShadowOriginPtrs = IRB.CreateCall(Getter, Addr);
+    } else {
+      ShadowOriginPtrs = IRB.CreateCall(MS.MsanMetadataPtrForStoreN, {Addr, SizeVal});
+    }
+    Value *ShadowPtr = IRB.CreateExtractValue(ShadowOriginPtrs, 0);
+    ShadowPtr = IRB.CreatePointerCast(ShadowPtr, PointerType::get(ShadowTy, 0));
+    IRB.CreateStore(Shadow, ShadowPtr);
+    Value *OriginPtr = IRB.CreateExtractValue(ShadowOriginPtrs, 1);
+    paintOrigin(IRB, updateOrigin(Origin, IRB), OriginPtr, Size, OriginAlignment);
+    ///IRB.CreateStore(Origin, OriginPtr);
+  }
+
+  bool setShadowOriginForStoreKmsan(Instruction *I, Value *Addr,
+                                    Value *Shadow, Value *Origin) {
+    IRBuilder<> IRB(I);
+    Type *ShadowTy = Shadow->getType();
+    int Size = 1;
+    int BitWidth = dyn_cast<IntegerType>(ShadowTy)->getBitWidth();
+    if (isa<IntegerType>(ShadowTy)) {
+      // TODO(glider): visitAllocaInst() passes int8* as ShadowTy.
+      Size = BitWidth / 8;
+      // Make sure Size is at least 1 byte if the operand is i1.
+      if (Size * 8 < BitWidth)
+        Size++;
+    }
+    Shadow = IRB.CreateIntCast(Shadow, IRB.getInt64Ty(), /* signed */false);
+    Value *Setter = MS.getKmsanShadowOriginAccessFn(/*isStore*/ true, Size);
+    Origin = IRB.CreateIntCast(Origin, MS.IntptrTy, /* isSigned */ false);
+    Addr = IRB.CreatePointerCast(Addr, PointerType::get(IRB.getInt8Ty(), 0));
+    if (Setter) {
+      IRB.CreateCall(Setter, {Addr, Shadow, Origin});
+      return true;
+    } else {
+      Value *SizeVal = ConstantInt::get(IRB.getInt64Ty(), Size);
+      if (Size < 8) {
+        Setter = MS.StoreShadowOrigin_n_8_Fn;
+        IRB.CreateCall(Setter, {Addr, Shadow, Origin, SizeVal});
+        return true;
+      } else {
+        Constant *ConstantShadow = dyn_cast_or_null<Constant>(Shadow);
+        if (ConstantShadow && ConstantShadow->isZeroValue()) {
+          IRB.CreateCall(MS.MsanUnpoisonFn, {Addr, SizeVal});
+          return true;
+        } else {
+          // TODO(glider): Clang produces i80 stores for some structs with
+          // bitfields. Ignore them for now, we'll try to turn this behavior off
+          // in the future.
+          // Till then we unpoison the shadow if there's no callback for this
+          // access size.
+          IRB.CreateCall(MS.MsanUnpoisonFn, {Addr, SizeVal});
+          errs() << "Missing setter for the following instruction:\n"
+                 << *I << "\n";
+          errs() << "Shadow: " << *Shadow << "\n";
+          errs() << "Origin: " << *Origin << "\n";
+          return false;
+        }
+      }
+    }
+  }
+
+  void storeShadowOrigin(Instruction *I, Value *Addr,
+      Value *Shadow, Value *Origin, bool InstrumentWithCalls, int StoreAlignment) {
+    if (MS.CompileKernel) {
+      if (!ClKmsanUseMetaPointers) {
+        if (!Origin) errs() << "!Origin @" << __LINE__ << "\n";
+        setShadowOriginForStoreKmsan(I, Addr, Shadow, Origin);
+      } else {
+        setShadowOriginForStoreKmsanPtrs(I, Addr, Shadow, Origin);
+      }
+    } else {
+      IRBuilder<> IRB(I);
+      Value *ShadowPtr = getShadowPtr(Addr, Shadow->getType(), IRB);
+
+      StoreInst *NewI =
+          IRB.CreateAlignedStore(Shadow, ShadowPtr, StoreAlignment);
+      DEBUG(dbgs() << "  STORE: " << *NewI << "\n");
+      (void)NewI;
+      if (MS.TrackOrigins && !I->isAtomic())
+        storeOrigin(IRB, Addr, Shadow, Origin, StoreAlignment, InstrumentWithCalls);
+    }
+  }
+
   void materializeStores(bool InstrumentWithCalls) {
     for (StoreInst *SI : StoreList) {
       IRBuilder<> IRB(SI);
@@ -759,23 +1076,37 @@
       Value *Val = SI->getValueOperand();
       Value *Addr = SI->getPointerOperand();
       Value *Shadow = SI->isAtomic() ? getCleanShadow(Val) : getShadow(Val);
-      Value *ShadowPtr = getShadowPtr(Addr, Shadow->getType(), IRB);
-
-      StoreInst *NewSI =
-          IRB.CreateAlignedStore(Shadow, ShadowPtr, SI->getAlignment());
-      DEBUG(dbgs() << "  STORE: " << *NewSI << "\n");
-      (void)NewSI;
-
+      Value *Origin = MS.TrackOrigins ? getOrigin(Val) : nullptr;
+      if (!Origin) {
+        errs() << "=============\n";
+        errs() << "SI: " << *SI << "\n";
+        errs() << "=============\n";
+        errs() << *SI->getParent();
+        errs() << "=============\n";
+        errs() << "MS.TrackOrigins: " << MS.TrackOrigins << "\n";
+        errs() << "Val: " << *Val << "\n";
+        errs() << "!Origin @" << __LINE__ << "\n";
+      }
+      storeShadowOrigin(SI, Addr, Shadow, Origin, InstrumentWithCalls, SI->getAlignment());
       if (ClCheckAccessAddress)
         insertShadowCheck(Addr, SI);
-
       if (SI->isAtomic())
         SI->setOrdering(addReleaseOrdering(SI->getOrdering()));
+    }
+  }
 
-      if (MS.TrackOrigins && !SI->isAtomic())
-        storeOrigin(IRB, Addr, Shadow, getOrigin(Val), SI->getAlignment(),
-                    InstrumentWithCalls);
+  /// \brief Helper function to insert a warning at IRB's current insert point.
+  void insertWarningFn(IRBuilder<> &IRB, Value *Origin) {
+    if (!Origin) Origin = (Value *)IRB.getInt32(0);
+    if (!MS.CompileKernel) {
+      if (MS.TrackOrigins) {
+        IRB.CreateStore(Origin, MS.OriginTLS);
+      }
+      IRB.CreateCall(MS.WarningFn, {});
+    } else {
+      IRB.CreateCall(MS.MsanWarning32Fn, Origin);
     }
+    IRB.CreateCall(MS.EmptyAsm, {});
   }
 
   void materializeOneCheck(Instruction *OrigIns, Value *Shadow, Value *Origin,
@@ -788,12 +1119,7 @@
     Constant *ConstantShadow = dyn_cast_or_null<Constant>(ConvertedShadow);
     if (ConstantShadow) {
       if (ClCheckConstantShadow && !ConstantShadow->isZeroValue()) {
-        if (MS.TrackOrigins) {
-          IRB.CreateStore(Origin ? (Value *)Origin : (Value *)IRB.getInt32(0),
-                          MS.OriginTLS);
-        }
-        IRB.CreateCall(MS.WarningFn, {});
-        IRB.CreateCall(MS.EmptyAsm, {});
+        insertWarningFn(IRB, Origin);
         // FIXME: Insert UnreachableInst if !MS.Recover?
         // This may invalidate some of the following checks and needs to be done
         // at the very end.
@@ -820,12 +1146,7 @@
           /* Unreachable */ !MS.Recover, MS.ColdCallWeights);
 
       IRB.SetInsertPoint(CheckTerm);
-      if (MS.TrackOrigins) {
-        IRB.CreateStore(Origin ? (Value *)Origin : (Value *)IRB.getInt32(0),
-                        MS.OriginTLS);
-      }
-      IRB.CreateCall(MS.WarningFn, {});
-      IRB.CreateCall(MS.EmptyAsm, {});
+      insertWarningFn(IRB, Origin);
       DEBUG(dbgs() << "  CHECK: " << *Cmp << "\n");
     }
   }
@@ -840,9 +1161,30 @@
     DEBUG(dbgs() << "DONE:\n" << F);
   }
 
+  BasicBlock *insertKmsanPrologue(Function &F) {
+    BasicBlock *ret =
+        SplitBlock(&F.getEntryBlock(), F.getEntryBlock().getFirstNonPHI());
+    IRBuilder<> IRB(F.getEntryBlock().getFirstNonPHI());
+    Value *ContextState = IRB.CreateCall(MS.GetContextStateFn, {});
+    Constant *Zero = IRB.getInt32(0);
+    MS.ParamTLS = IRB.CreateGEP(ContextState, {Zero, IRB.getInt32(0)});
+    MS.RetvalTLS = IRB.CreateGEP(ContextState, {Zero, IRB.getInt32(1)});
+    MS.VAArgTLS = IRB.CreateGEP(ContextState, {Zero, IRB.getInt32(2)});
+    MS.VAArgOverflowSizeTLS =
+        IRB.CreateGEP(ContextState, {Zero, IRB.getInt32(3)});
+    MS.ParamOriginTLS = IRB.CreateGEP(ContextState, {Zero, IRB.getInt32(4)});
+    MS.RetvalOriginTLS = IRB.CreateGEP(ContextState, {Zero, IRB.getInt32(5)});
+    MS.OriginTLS = IRB.CreateGEP(ContextState, {Zero, IRB.getInt32(6)});
+    return ret;
+  }
+
   /// \brief Add MemorySanitizer instrumentation to a function.
   bool runOnFunction() {
     MS.initializeCallbacks(*F.getParent());
+    if (MS.CompileKernel)
+      ActualFnStart = insertKmsanPrologue(F);
+    else
+      ActualFnStart = &F.getEntryBlock();
 
     // In the presence of unreachable blocks, we may see Phi nodes with
     // incoming nodes from such blocks. Since InstVisitor skips unreachable
@@ -853,7 +1195,7 @@
     // Iterate all BBs in depth-first order and create shadow instructions
     // for all instructions (where applicable).
     // For PHI nodes we create dummy shadow PHIs which will be finalized later.
-    for (BasicBlock *BB : depth_first(&F.getEntryBlock()))
+    for (BasicBlock *BB : depth_first(ActualFnStart))
       visit(*BB);
 
 
@@ -958,8 +1300,8 @@
   /// address.
   ///
   /// Shadow = ShadowBase + Offset
-  Value *getShadowPtr(Value *Addr, Type *ShadowTy,
-                      IRBuilder<> &IRB) {
+  Value *getShadowPtr(Value *Addr, Type *ShadowTy, IRBuilder<> &IRB) {
+    assert(!MS.CompileKernel);
     Value *ShadowLong = getShadowPtrOffset(Addr, IRB);
     uint64_t ShadowBase = MS.MapParams->ShadowBase;
     if (ShadowBase != 0)
@@ -1084,6 +1426,18 @@
     return Constant::getNullValue(MS.OriginTy);
   }
 
+  /// \brief Unpoison an aligned byte range.
+  void unpoisonRange(IRBuilder<> &IRB, Value *Addr, unsigned Size, unsigned ArgAlign) {
+    if (!MS.CompileKernel) {
+      IRB.CreateMemSet(
+          getShadowPtr(Addr, IRB.getInt8Ty(), IRB),
+          Constant::getNullValue(IRB.getInt8Ty()), Size, ArgAlign);
+    } else {
+      Value *SizeVal = ConstantInt::get(MS.IntptrTy, Size);
+      IRB.CreateCall(MS.MsanUnpoisonFn, {Addr, SizeVal});
+    }
+  }
+
   /// \brief Get the shadow value for a given Value.
   ///
   /// This function either returns the value set earlier with setShadow,
@@ -1112,7 +1466,7 @@
       if (*ShadowPtr)
         return *ShadowPtr;
       Function *F = A->getParent();
-      IRBuilder<> EntryIRB(F->getEntryBlock().getFirstNonPHI());
+      IRBuilder<> EntryIRB(ActualFnStart->getFirstNonPHI());
       unsigned ArgOffset = 0;
       const DataLayout &DL = F->getParent()->getDataLayout();
       for (auto &FArg : F->args()) {
@@ -1138,16 +1492,24 @@
             }
             if (Overflow) {
               // ParamTLS overflow.
-              EntryIRB.CreateMemSet(
-                  getShadowPtr(V, EntryIRB.getInt8Ty(), EntryIRB),
-                  Constant::getNullValue(EntryIRB.getInt8Ty()), Size, ArgAlign);
+              unpoisonRange(EntryIRB, V, Size, ArgAlign);
             } else {
-              unsigned CopyAlign = std::min(ArgAlign, kShadowTLSAlignment);
-              Value *Cpy = EntryIRB.CreateMemCpy(
-                  getShadowPtr(V, EntryIRB.getInt8Ty(), EntryIRB), Base, Size,
-                  CopyAlign);
-              DEBUG(dbgs() << "  ByValCpy: " << *Cpy << "\n");
-              (void)Cpy;
+              if (!MS.CompileKernel) {
+                unsigned CopyAlign = std::min(ArgAlign, kShadowTLSAlignment);
+                Value *Cpy = EntryIRB.CreateMemCpy(
+                    getShadowPtr(V, EntryIRB.getInt8Ty(), EntryIRB), Base, Size,
+                    CopyAlign);
+                DEBUG(dbgs() << "  ByValCpy: " << *Cpy << "\n");
+                (void)Cpy;
+              } else {
+                // The above alignment is unused, because KMSAN runtime doesn't
+                // make any assumptions about it.
+                Value *SizeVal = ConstantInt::get(MS.IntptrTy, Size);
+                V = EntryIRB.CreatePointerCast(V, EntryIRB.getInt8PtrTy());
+                Base =
+                    EntryIRB.CreatePointerCast(Base, EntryIRB.getInt8PtrTy());
+                EntryIRB.CreateCall(MS.MsanLoadArgShadowFn, {V, Base, SizeVal});
+              }
             }
             *ShadowPtr = getCleanShadow(V);
           } else {
@@ -1271,11 +1633,11 @@
 
   // ------------------- Visitors.
 
-  /// \brief Instrument LoadInst
+  /// \brief Instrument LoadInst in the userspace.
   ///
   /// Loads the corresponding shadow and (optionally) origin.
   /// Optionally, checks that the load address is fully defined.
-  void visitLoadInst(LoadInst &I) {
+  void visitLoadInstUserspace(LoadInst &I) {
     assert(I.getType()->isSized() && "Load type must have size");
     IRBuilder<> IRB(I.getNextNode());
     Type *ShadowTy = getShadowTy(&I);
@@ -1288,12 +1650,6 @@
       setShadow(&I, getCleanShadow(&I));
     }
 
-    if (ClCheckAccessAddress)
-      insertShadowCheck(I.getPointerOperand(), &I);
-
-    if (I.isAtomic())
-      I.setOrdering(addAcquireOrdering(I.getOrdering()));
-
     if (MS.TrackOrigins) {
       if (PropagateShadow) {
         unsigned Alignment = I.getAlignment();
@@ -1306,6 +1662,126 @@
     }
   }
 
+  /// \brief Instrument LoadInst in the kernel.
+  void visitLoadInstKmsan(LoadInst &I) {
+    assert(I.getType()->isSized() && "Load type must have size");
+    IRBuilder<> IRB(I.getNextNode());
+    Type *ShadowTy = getShadowTy(&I);
+    Value *Addr = I.getPointerOperand();
+    if (PropagateShadow && !I.getMetadata("nosanitize")) {
+#if 0
+      int BitWidth = dyn_cast<IntegerType>(ShadowTy)->getBitWidth();
+      if (isa<IntegerType>(ShadowTy)) {
+        // TODO(glider): visitAllocaInst() passes int8* as ShadowTy.
+        Size = BitWidth / 8;
+        // Make sure Size is at least 1 if the operand is i1.
+        if (Size * 8 < BitWidth)
+          Size++;
+      }
+#endif
+      int BitWidth = VectorOrPrimitiveTypeSizeInBits(ShadowTy);
+      int Size = BitWidth / 8;
+      // Make sure Size is at least 1 if the operand is i1.
+      if (Size * 8 < BitWidth)
+        Size++;
+
+      Addr = IRB.CreatePointerCast(Addr, PointerType::get(IRB.getInt8Ty(), 0));
+      Value *Getter = MS.getKmsanShadowOriginAccessFn(/*isStore*/ false, Size);
+      Value *Shadow = nullptr, *Origin = nullptr;
+      if (Size <= 8) {
+        Value *ShadowOrigin = nullptr;
+        if (!Getter) {
+          if (Size > 8) {
+            errs() << "Missing getter for the following instruction:\n"
+                   << I << "\n";
+            // Currently there is no evidence of Clang generating non-power-of-2
+            // accesses in the kernel.
+            assert(false);
+          } else {
+            Getter = MS.LoadShadowOrigin_n_8_Fn;
+            Value *SizeVal = ConstantInt::get(IRB.getInt64Ty(), Size);
+            ShadowOrigin = IRB.CreateCall(Getter, {Addr, SizeVal});
+          }
+        } else {
+          ShadowOrigin = IRB.CreateCall(Getter, Addr);
+        }
+        Shadow = IRB.CreateExtractValue(ShadowOrigin, 0);
+        Shadow = IRB.CreateIntCast(Shadow, ShadowTy, /* isSigned */ false);
+        Origin = IRB.CreateExtractValue(ShadowOrigin, 1);
+      } else {
+        Value *SizeVal = ConstantInt::get(IRB.getInt64Ty(), Size);
+        Value *ShadowOriginPtrs = IRB.CreateCall(MS.MsanMetadataPtrForLoadN, {Addr, SizeVal});
+        Value *ShadowPtr = IRB.CreateExtractValue(ShadowOriginPtrs, 0);
+        ShadowPtr = IRB.CreatePointerCast(ShadowPtr, PointerType::get(ShadowTy, 0));
+        Shadow = IRB.CreateLoad(ShadowPtr);
+        Value *OriginPtr = IRB.CreateExtractValue(ShadowOriginPtrs, 1);
+        Origin = IRB.CreateLoad(OriginPtr);
+      }
+
+      setShadow(&I, Shadow);
+      ///errs() << "setting origin for instruction: " << I << ",\nOrigin: " << *Origin << "\n";
+      setOrigin(&I, Origin);
+    } else {
+      setShadow(&I, getCleanShadow(&I));
+      setOrigin(&I, getCleanOrigin());
+    }
+  }
+
+  /// \brief Instrument LoadInst in the kernel.
+  void visitLoadInstKmsanPtrs(LoadInst &I) {
+    assert(I.getType()->isSized() && "Load type must have size");
+    IRBuilder<> IRB(I.getNextNode());
+    Type *ShadowTy = getShadowTy(&I);
+    Value *Addr = I.getPointerOperand();
+    if (PropagateShadow && !I.getMetadata("nosanitize")) {
+      int BitWidth = VectorOrPrimitiveTypeSizeInBits(ShadowTy);
+      int Size = BitWidth / 8;
+      // Make sure Size is at least 1 if the operand is i1.
+      if (Size * 8 < BitWidth)
+        Size++;
+      Value *SizeVal = ConstantInt::get(IRB.getInt64Ty(), Size);
+
+      Addr = IRB.CreatePointerCast(Addr, PointerType::get(IRB.getInt8Ty(), 0));
+      Value *ShadowOriginPtrs;
+      Value *Getter = MS.getKmsanShadowOriginAccessFn(/*isStore*/ false, Size);
+      if (Getter) {
+        ShadowOriginPtrs = IRB.CreateCall(Getter, Addr);
+      } else {
+        ShadowOriginPtrs = IRB.CreateCall(MS.MsanMetadataPtrForLoadN, {Addr, SizeVal});
+      }
+      Value *ShadowPtr = IRB.CreateExtractValue(ShadowOriginPtrs, 0);
+      ShadowPtr = IRB.CreatePointerCast(ShadowPtr, PointerType::get(ShadowTy, 0));
+      Value *Shadow = IRB.CreateLoad(ShadowPtr);
+      Value *OriginPtr = IRB.CreateExtractValue(ShadowOriginPtrs, 1);
+      Value *Origin = IRB.CreateLoad(OriginPtr);
+
+      setShadow(&I, Shadow);
+      setOrigin(&I, Origin);
+    } else {
+      setShadow(&I, getCleanShadow(&I));
+      setOrigin(&I, getCleanOrigin());
+    }
+  }
+
+
+  void visitLoadInst(LoadInst &I) {
+    if (MS.CompileKernel) {
+      if (!ClKmsanUseMetaPointers) {
+        visitLoadInstKmsan(I);
+      } else {
+        visitLoadInstKmsanPtrs(I);
+      }
+    } else {
+      visitLoadInstUserspace(I);
+    }
+
+    if (ClCheckAccessAddress)
+      insertShadowCheck(I.getPointerOperand(), &I);
+
+    if (I.isAtomic())
+      I.setOrdering(addAcquireOrdering(I.getOrdering()));
+  }
+
   /// \brief Instrument StoreInst
   ///
   /// Stores the corresponding shadow and (optionally) origin.
@@ -1319,7 +1795,6 @@
 
     IRBuilder<> IRB(&I);
     Value *Addr = I.getOperand(0);
-    Value *ShadowPtr = getShadowPtr(Addr, I.getType(), IRB);
 
     if (ClCheckAccessAddress)
       insertShadowCheck(Addr, &I);
@@ -1330,8 +1805,7 @@
     if (isa<AtomicCmpXchgInst>(I))
       insertShadowCheck(I.getOperand(1), &I);
 
-    IRB.CreateStore(getCleanShadow(&I), ShadowPtr);
-
+    storeShadowOrigin(&I, Addr, getCleanShadow(&I), getCleanOrigin(), /*InstrumentWithCalls*/false, /*SI->getAlignment()*/1);
     setShadow(&I, getCleanShadow(&I));
     setOrigin(&I, getCleanOrigin());
   }
@@ -1940,18 +2414,16 @@
     IRBuilder<> IRB(&I);
     Value* Addr = I.getArgOperand(0);
     Value *Shadow = getShadow(&I, 1);
-    Value *ShadowPtr = getShadowPtr(Addr, Shadow->getType(), IRB);
+    Value *Origin = MS.TrackOrigins ? getOrigin(&I, 1) : nullptr;
 
     // We don't know the pointer alignment (could be unaligned SSE store!).
     // Have to assume to worst case.
-    IRB.CreateAlignedStore(Shadow, ShadowPtr, 1);
+    if (!Origin) errs() << "!Origin @" << __LINE__ << "\n";
+    storeShadowOrigin(&I, Addr, Shadow, Origin, /*InstrumentWithCalls*/false, /*StoreAlignment*/1);
 
     if (ClCheckAccessAddress)
       insertShadowCheck(Addr, &I);
 
-    // FIXME: factor out common code from materializeStores
-    if (MS.TrackOrigins)
-      IRB.CreateStore(getOrigin(&I, 1), getOriginPtr(Addr, IRB, 1));
     return true;
   }
 
@@ -1960,6 +2432,8 @@
   /// Instrument intrinsics that look like a simple SIMD load: reads memory,
   /// has 1 pointer argument, returns a vector.
   bool handleVectorLoadIntrinsic(IntrinsicInst &I) {
+    // FIXME: KMSAN instrumentation doesn't handle vector instructions for now.
+    assert(!MS.CompileKernel);
     IRBuilder<> IRB(&I);
     Value *Addr = I.getArgOperand(0);
 
@@ -2647,9 +3121,23 @@
         if (ArgOffset + Size > kParamTLSSize) break;
         unsigned ParamAlignment = CS.getParamAlignment(i);
         unsigned Alignment = std::min(ParamAlignment, kShadowTLSAlignment);
-        Store = IRB.CreateMemCpy(ArgShadowBase,
-                                 getShadowPtr(A, Type::getInt8Ty(*MS.C), IRB),
-                                 Size, Alignment);
+        if (!MS.CompileKernel) {
+          Store = IRB.CreateMemCpy(ArgShadowBase,
+                                   getShadowPtr(A, Type::getInt8Ty(*MS.C), IRB),
+                                   Size, Alignment);
+        } else {
+          // Not using the above alignment, as KMSAN runtime doesn't make any
+          // assumptions about it.
+          Value *SizeVal = ConstantInt::get(MS.IntptrTy, Size);
+          ArgShadowBase =
+              IRB.CreatePointerCast(ArgShadowBase, IRB.getInt8PtrTy());
+          A = IRB.CreatePointerCast(A, IRB.getInt8PtrTy());
+          ///IRB.CreateCall(MS.MsanStoreArgShadowFn, {ArgShadowBase, A, SizeVal});
+          Value *OriginPtr = getOriginPtrForArgument(A, IRB, ArgOffset);
+          OriginPtr = IRB.CreatePointerCast(OriginPtr, IRB.getInt8PtrTy());
+          ///IRB.CreateCall(MS.MsanStoreArgOriginFn, {OriginPtr, A, SizeVal});
+          IRB.CreateCall(MS.MsanStoreArgShadowOriginFn, {ArgShadowBase, OriginPtr, A, SizeVal});
+        }
       } else {
         Size = DL.getTypeAllocSize(A->getType());
         if (ArgOffset + Size > kParamTLSSize) break;
@@ -2658,11 +3146,14 @@
         Constant *Cst = dyn_cast<Constant>(ArgShadow);
         if (Cst && Cst->isNullValue()) ArgIsInitialized = true;
       }
-      if (MS.TrackOrigins && !ArgIsInitialized)
-        IRB.CreateStore(getOrigin(A),
-                        getOriginPtrForArgument(A, IRB, ArgOffset));
-      (void)Store;
-      assert(Size != 0 && Store != nullptr);
+      if (!MS.CompileKernel) {
+        if (MS.TrackOrigins && !ArgIsInitialized) {
+          IRB.CreateStore(getOrigin(A),
+                          getOriginPtrForArgument(A, IRB, ArgOffset));
+        }
+        (void)Store;
+        assert((Size != 0 && Store != nullptr));
+      }
       DEBUG(dbgs() << "  Param:" << *Store << "\n");
       ArgOffset += alignTo(Size, 8);
     }
@@ -2733,8 +3224,9 @@
     } else {
       Value *Shadow = getShadow(RetVal);
       IRB.CreateAlignedStore(Shadow, ShadowPtr, kShadowTLSAlignment);
-      if (MS.TrackOrigins)
+      if (MS.TrackOrigins) {
         IRB.CreateStore(getOrigin(RetVal), getOriginPtrForRetval(IRB));
+      }
     }
   }
 
@@ -2754,15 +3246,20 @@
                                   "_msphi_o"));
   }
 
-  void visitAllocaInst(AllocaInst &I) {
-    setShadow(&I, getCleanShadow(&I));
-    setOrigin(&I, getCleanOrigin());
-    IRBuilder<> IRB(I.getNextNode());
-    const DataLayout &DL = F.getParent()->getDataLayout();
-    uint64_t TypeSize = DL.getTypeAllocSize(I.getAllocatedType());
-    Value *Len = ConstantInt::get(MS.IntptrTy, TypeSize);
-    if (I.isArrayAllocation())
-      Len = IRB.CreateMul(Len, I.getArraySize());
+  Value *getLocalVarDescription(AllocaInst &I) {
+    SmallString<2048> StackDescriptionStorage;
+    raw_svector_ostream StackDescription(StackDescriptionStorage);
+    // We create a string with a description of the stack allocation and
+    // pass it into __msan_set_alloca_origin.
+    // It will be printed by the run-time if stack-originated UMR is found.
+    // The first 4 bytes of the string are set to '----' and will be replaced
+    // by __msan_va_arg_overflow_size_tls at the first call.
+    StackDescription << "----" << I.getName() << "@" << F.getName();
+    return createPrivateNonConstGlobalForString(*F.getParent(),
+                                                StackDescription.str());
+  }
+
+  void instrumentAllocaUserspace(AllocaInst &I, IRBuilder<> &IRB, Value *Len) {
     if (PoisonStack && ClPoisonStackWithCall) {
       IRB.CreateCall(MS.MsanPoisonStackFn,
                      {IRB.CreatePointerCast(&I, IRB.getInt8PtrTy()), Len});
@@ -2773,18 +3270,7 @@
     }
 
     if (PoisonStack && MS.TrackOrigins) {
-      SmallString<2048> StackDescriptionStorage;
-      raw_svector_ostream StackDescription(StackDescriptionStorage);
-      // We create a string with a description of the stack allocation and
-      // pass it into __msan_set_alloca_origin.
-      // It will be printed by the run-time if stack-originated UMR is found.
-      // The first 4 bytes of the string are set to '----' and will be replaced
-      // by __msan_va_arg_overflow_size_tls at the first call.
-      StackDescription << "----" << I.getName() << "@" << F.getName();
-      Value *Descr =
-          createPrivateNonConstGlobalForString(*F.getParent(),
-                                               StackDescription.str());
-
+      Value *Descr = getLocalVarDescription(I);
       IRB.CreateCall(MS.MsanSetAllocaOrigin4Fn,
                      {IRB.CreatePointerCast(&I, IRB.getInt8PtrTy()), Len,
                       IRB.CreatePointerCast(Descr, IRB.getInt8PtrTy()),
@@ -2792,6 +3278,33 @@
     }
   }
 
+  void instrumentAllocaKmsan(AllocaInst &I, IRBuilder<> &IRB, Value *Len) {
+    Value *Descr = getLocalVarDescription(I);
+    Value *Pc = IRB.CreateCall(
+        Intrinsic::getDeclaration(F.getParent(), Intrinsic::returnaddress),
+        IRB.getInt32(0));
+    IRB.CreateCall(MS.MsanPoisonAllocaFn,
+                   {IRB.CreatePointerCast(&I, IRB.getInt8PtrTy()), Len,
+                    IRB.CreatePointerCast(Descr, IRB.getInt8PtrTy()),
+                    IRB.CreatePointerCast(Pc, MS.IntptrTy)});
+  }
+
+  void visitAllocaInst(AllocaInst &I) {
+    setShadow(&I, getCleanShadow(&I));
+    setOrigin(&I, getCleanOrigin());
+    IRBuilder<> IRB(I.getNextNode());
+    const DataLayout &DL = F.getParent()->getDataLayout();
+    uint64_t TypeSize = DL.getTypeAllocSize(I.getAllocatedType());
+    Value *Len = ConstantInt::get(MS.IntptrTy, TypeSize);
+    if (I.isArrayAllocation())
+      Len = IRB.CreateMul(Len, I.getArraySize());
+
+    if (!MS.CompileKernel)
+      instrumentAllocaUserspace(I, IRB, Len);
+    else
+      instrumentAllocaKmsan(I, IRB, Len);
+  }
+
   void visitSelectInst(SelectInst& I) {
     IRBuilder<> IRB(&I);
     // a = select b, c, d
@@ -2993,8 +3506,15 @@
         uint64_t ArgSize = DL.getTypeAllocSize(RealTy);
         Value *Base = getShadowPtrForVAArgument(RealTy, IRB, OverflowOffset);
         OverflowOffset += alignTo(ArgSize, 8);
-        IRB.CreateMemCpy(Base, MSV.getShadowPtr(A, IRB.getInt8Ty(), IRB),
-                         ArgSize, kShadowTLSAlignment);
+        if (!MS.CompileKernel) {
+          IRB.CreateMemCpy(Base, MSV.getShadowPtr(A, IRB.getInt8Ty(), IRB),
+                           ArgSize, kShadowTLSAlignment);
+        } else {
+          Value *ArgSizeV = ConstantInt::get(MS.IntptrTy, ArgSize);
+          Base = IRB.CreatePointerCast(Base, IRB.getInt8PtrTy());
+          A = IRB.CreatePointerCast(A, IRB.getInt8PtrTy());
+          IRB.CreateCall(MS.MsanStoreArgShadowFn, {Base, A, ArgSizeV});
+        }
       } else {
         ArgKind AK = classifyArgument(A);
         if (AK == AK_GeneralPurpose && GpOffset >= AMD64GpEndOffset)
@@ -3039,33 +3559,40 @@
                               "_msarg");
   }
 
-  void visitVAStartInst(VAStartInst &I) override {
-    if (F.getCallingConv() == CallingConv::Win64)
-      return;
+  void unpoisonVAListTagForInst(IntrinsicInst &I) {
     IRBuilder<> IRB(&I);
-    VAStartInstrumentationList.push_back(&I);
     Value *VAListTag = I.getArgOperand(0);
-    Value *ShadowPtr = MSV.getShadowPtr(VAListTag, IRB.getInt8Ty(), IRB);
-
     // Unpoison the whole __va_list_tag.
     // FIXME: magic ABI constants.
-    IRB.CreateMemSet(ShadowPtr, Constant::getNullValue(IRB.getInt8Ty()),
-                     /* size */24, /* alignment */8, false);
+    MSV.unpoisonRange(IRB, VAListTag, 24,  8);
   }
 
-  void visitVACopyInst(VACopyInst &I) override {
+  void visitVAStartInst(VAStartInst &I) {
     if (F.getCallingConv() == CallingConv::Win64)
       return;
-    IRBuilder<> IRB(&I);
-    Value *VAListTag = I.getArgOperand(0);
-    Value *ShadowPtr = MSV.getShadowPtr(VAListTag, IRB.getInt8Ty(), IRB);
+    VAStartInstrumentationList.push_back(&I);
+    unpoisonVAListTagForInst(I);
+  }
 
-    // Unpoison the whole __va_list_tag.
-    // FIXME: magic ABI constants.
-    IRB.CreateMemSet(ShadowPtr, Constant::getNullValue(IRB.getInt8Ty()),
-                     /* size */24, /* alignment */8, false);
+  void visitVACopyInst(VACopyInst &I) {
+    if (F.getCallingConv() == CallingConv::Win64)
+      return;
+    unpoisonVAListTagForInst(I);
   }
 
+  void createMemcpyForArgs(
+      IRBuilder<> &IRB, Value *DstPtr, Value *SrcPtr, Value *Size) {
+    if (!MS.CompileKernel) {
+      Value *DstShadowPtr =
+          MSV.getShadowPtr(DstPtr, IRB.getInt8Ty(), IRB);
+      IRB.CreateMemCpy(DstShadowPtr, SrcPtr, Size, 16);
+    } else {
+      DstPtr =
+          IRB.CreateIntToPtr(DstPtr, IRB.getInt8PtrTy());
+      IRB.CreateCall(MS.MsanLoadArgShadowFn, {DstPtr, SrcPtr, Size});
+    }
+  }
+
   void finalizeInstrumentation() override {
     assert(!VAArgOverflowSize && !VAArgTLSCopy &&
            "finalizeInstrumentation called twice");
@@ -3072,7 +3599,7 @@
     if (!VAStartInstrumentationList.empty()) {
       // If there is a va_start in this function, make a backup copy of
       // va_arg_tls somewhere in the function entry block.
-      IRBuilder<> IRB(F.getEntryBlock().getFirstNonPHI());
+      IRBuilder<> IRB(MSV.ActualFnStart->getFirstNonPHI());
       VAArgOverflowSize = IRB.CreateLoad(MS.VAArgOverflowSizeTLS);
       Value *CopySize =
         IRB.CreateAdd(ConstantInt::get(MS.IntptrTy, AMD64FpEndOffset),
@@ -3094,10 +3621,8 @@
                         ConstantInt::get(MS.IntptrTy, 16)),
           Type::getInt64PtrTy(*MS.C));
       Value *RegSaveAreaPtr = IRB.CreateLoad(RegSaveAreaPtrPtr);
-      Value *RegSaveAreaShadowPtr =
-        MSV.getShadowPtr(RegSaveAreaPtr, IRB.getInt8Ty(), IRB);
-      IRB.CreateMemCpy(RegSaveAreaShadowPtr, VAArgTLSCopy,
-                       AMD64FpEndOffset, 16);
+      createMemcpyForArgs(IRB, RegSaveAreaPtr, VAArgTLSCopy,
+                          ConstantInt::get(MS.IntptrTy, AMD64FpEndOffset));
 
       Value *OverflowArgAreaPtrPtr =
         IRB.CreateIntToPtr(
@@ -3105,11 +3630,9 @@
                         ConstantInt::get(MS.IntptrTy, 8)),
           Type::getInt64PtrTy(*MS.C));
       Value *OverflowArgAreaPtr = IRB.CreateLoad(OverflowArgAreaPtrPtr);
-      Value *OverflowArgAreaShadowPtr =
-        MSV.getShadowPtr(OverflowArgAreaPtr, IRB.getInt8Ty(), IRB);
       Value *SrcPtr = IRB.CreateConstGEP1_32(IRB.getInt8Ty(), VAArgTLSCopy,
                                              AMD64FpEndOffset);
-      IRB.CreateMemCpy(OverflowArgAreaShadowPtr, SrcPtr, VAArgOverflowSize, 16);
+      createMemcpyForArgs(IRB, OverflowArgAreaPtr, SrcPtr, VAArgOverflowSize);
     }
   }
 };
@@ -3175,7 +3698,7 @@
                      /* size */8, /* alignment */8, false);
   }
 
-  void visitVACopyInst(VACopyInst &I) override {
+  void visitVACopyInst(VACopyInst &I) {
     IRBuilder<> IRB(&I);
     Value *VAListTag = I.getArgOperand(0);
     Value *ShadowPtr = MSV.getShadowPtr(VAListTag, IRB.getInt8Ty(), IRB);
@@ -3188,7 +3711,7 @@
   void finalizeInstrumentation() override {
     assert(!VAArgSize && !VAArgTLSCopy &&
            "finalizeInstrumentation called twice");
-    IRBuilder<> IRB(F.getEntryBlock().getFirstNonPHI());
+    IRBuilder<> IRB(MSV.ActualFnStart->getFirstNonPHI());
     VAArgSize = IRB.CreateLoad(MS.VAArgOverflowSizeTLS);
     Value *CopySize = IRB.CreateAdd(ConstantInt::get(MS.IntptrTy, 0),
                                     VAArgSize);
@@ -3369,7 +3892,7 @@
     if (!VAStartInstrumentationList.empty()) {
       // If there is a va_start in this function, make a backup copy of
       // va_arg_tls somewhere in the function entry block.
-      IRBuilder<> IRB(F.getEntryBlock().getFirstNonPHI());
+      IRBuilder<> IRB(MSV.ActualFnStart->getFirstNonPHI());
       VAArgOverflowSize = IRB.CreateLoad(MS.VAArgOverflowSizeTLS);
       Value *CopySize =
         IRB.CreateAdd(ConstantInt::get(MS.IntptrTy, AArch64VAEndOffset),
@@ -3591,7 +4114,7 @@
   void finalizeInstrumentation() override {
     assert(!VAArgSize && !VAArgTLSCopy &&
            "finalizeInstrumentation called twice");
-    IRBuilder<> IRB(F.getEntryBlock().getFirstNonPHI());
+    IRBuilder<> IRB(MSV.ActualFnStart->getFirstNonPHI());
     VAArgSize = IRB.CreateLoad(MS.VAArgOverflowSizeTLS);
     Value *CopySize = IRB.CreateAdd(ConstantInt::get(MS.IntptrTy, 0),
                                     VAArgSize);
@@ -3666,5 +4189,8 @@
     .addAttribute(Attribute::ReadNone);
   F.removeAttributes(AttributeList::FunctionIndex, B);
 
-  return Visitor.runOnFunction();
+  ///errs() << F;
+  bool ret = Visitor.runOnFunction();
+  ///errs() << F;
+  return ret;
 }
